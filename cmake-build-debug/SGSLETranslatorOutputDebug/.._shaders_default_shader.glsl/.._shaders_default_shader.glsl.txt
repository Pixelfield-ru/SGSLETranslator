#sg_pragma once
#sg_include "../defines.glsl"
#sg_include "../uniform_bufs_decl.glsl"
#sg_pragma once
#sg_include "../ray_intersections.glsl"
#sg_include "default_shader.glsl"
#define PI 3.141592
#define iSteps 16
#define jSteps 8
vec3 atmosphere(vec3 r, vec3 ro, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {
	pSun = normalize(pSun);
	r = normalize(r);
	vec2 p = raySphereIntersection(ro, r, rAtmos);
	if (p.x > p.y) return vec3(0,0,0);
	p.y = min(p.y, raySphereIntersection(ro, r, rPlanet).x);
	float iStepSize = (p.y - p.x) / float(iSteps);
	float iTime = 0.0;
	vec3 totalRlh = vec3(0,0,0);
	vec3 totalMie = vec3(0,0,0);
	float iOdRlh = 0.0;
	float iOdMie = 0.0;
	float mu = dot(r, pSun);
	float mumu = mu * mu;
	float gg = g * g;
	float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);
	float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));
	for (int i = 0;
	i < iSteps;
	i++) {
		vec3 iPos = ro + r * (iTime + iStepSize * 0.5);
		float iHeight = length(iPos) - rPlanet;
		float odStepRlh = exp(-iHeight / shRlh) * iStepSize;
		float odStepMie = exp(-iHeight / shMie) * iStepSize;
		iOdRlh += odStepRlh;
		iOdMie += odStepMie;
		float jStepSize = raySphereIntersection(iPos, pSun, rAtmos).y / float(jSteps);
		float jTime = 0.0;
		float jOdRlh = 0.0;
		float jOdMie = 0.0;
		for (int j = 0;
		j < jSteps;
		j++) {
			vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);
			float jHeight = length(jPos) - rPlanet;
			jOdRlh += exp(-jHeight / shRlh) * jStepSize;
			jOdMie += exp(-jHeight / shMie) * jStepSize;
			jTime += jStepSize;
		}
		vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));
		totalRlh += odStepRlh * attn;
		totalMie += odStepMie * attn;
		iTime += iStepSize;
	}
	return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);
}
#sg_include "atmosphere_scattering.glsl"
SGSubPass(GeometryPass) {
	SGSubShader(Vertex) {
		layout (location = 0) in vec3 positionsAttribute;
		layout (location = 1) in vec3 UVAttribute;
		layout (location = 2) in vec3 normalsAttribute;
		out vec3 vs_UVAttribute;
		void main() {
			vs_UVAttribute = positionsAttribute;
			gl_Position = camera.projectionMatrix * mat4(mat3(camera.viewMatrix)) * objectModelMatrix * vec4(positionsAttribute, 1.0);
		}
	}
	SGSubShader(Fragment) {
		layout(location = 0) out vec4 fragColor;
		const vec3 sunPos = vec3(0.0, 1.0, -1.0);
		SGUniformsDeclaration {
			SGUSamplerCube skyboxSamplers[1] = SGGetTexturesFromMaterial("SGTT_SKYBOX");
		}
		in vec3 vs_UVAttribute;
		void main() {
			vec3 atmosphereCol = atmosphere( vs_UVAttribute, vec3(0, 6372e3, 0), sunPos, 30.0, 6371e3, 6471e3, vec3(14.5e-6, 15.0e-6, 17.4e-6), 20e-6, 8e3, 1.0e3, 0.958 );
			if(skyboxSamplers.length() > 0) {
				float mixCoeff = 1.0 / skyboxSamplers.length();
				vec4 skyboxCol = vec4(0.0);
				for (int i = 0;
				i < skyboxSamplers.length();
				i++) {
					skyboxCol += texture(skyboxSamplers[i], vs_UVAttribute.xyz) * mixCoeff;
				}
				fragColor = vec4(atmosphereCol * skyboxCol.rgb, skyboxCol.a);
			}
			else {
				fragColor = vec4(atmosphereCol, 1.0);
			}
		}
	}
}
